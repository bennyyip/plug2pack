#[macro_use]
extern crate nom;

#[macro_use]
extern crate serde_derive;
extern crate serde_yaml;

extern crate structopt;
#[macro_use]
extern crate structopt_derive;

extern crate regex;

mod parser;

use std::collections::HashMap;
use std::fs::File;
use std::error::Error;
use std::io::prelude::*;
use std::io::BufReader;
use std::path::Path;

use structopt::StructOpt;
use parser::Value;
use regex::Regex;

#[derive(StructOpt, Debug)]
#[structopt(name = "plug2pack", about = "convert vim-plug config to pack")]
struct Opt {
    #[structopt(short = "i", long = "input", help = "Input file")]
    input: String,
    #[structopt(short = "o", long = "output", help = "Output file, stdout if not present")]
    output: Option<String>,
    #[structopt(long = "optional", help = "make all package optional")]
    optional: Option<bool>,
    #[structopt(long = "local", help = "make all package local")]
    local: Option<bool>,
    #[structopt(long = "category", help = "specify a category for all package")]
    category: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct Package {
    pub name: String,
    pub category: String,
    pub opt: bool,
    /// Load this package on this command
    #[serde(rename = "on")]
    pub load_command: Option<String>,
    /// Load this package for these types
    #[serde(rename = "for")]
    pub for_types: Option<Vec<String>>,
    /// Build command for this package
    #[serde(rename = "build")]
    pub build_command: Option<String>,
    /// Local plugin
    pub local: bool,
}

impl Package {
    fn new(
        name: &str,
        options: Option<HashMap<&str, Value>>,
        opt: Option<bool>,
        local: Option<bool>,
        category: Option<String>,
    ) -> Package {

        let mut for_types = None;
        let mut load_command = None;
        let mut build_command = None;

        if let Some(options) = options {
            for_types = match options.get("for") {
                Some(&Value::Str(ref s)) => Some(vec![s.clone()]),
                Some(&Value::Array(ref v)) => Some(v.clone()),
                None => None,
            };

            load_command = match options.get("on") {
                Some(&Value::Str(ref s)) => Some(s.clone()),
                _ => None,
            };

            build_command = match options.get("do") {
                Some(&Value::Str(ref s)) => Some(s.clone()),
                _ => None,
            };
        }

        let opt = load_command.is_some() || opt.unwrap_or(false);

        Package {
            name: name.to_owned(),
            category: category.unwrap_or_else(|| "default".to_owned()),
            opt: opt,
            load_command: load_command,
            for_types: for_types,
            build_command: build_command,
            local: local.unwrap_or(false),
        }
    }
}


fn main() {
    let opt = Opt::from_args();

    let path = Path::new(&opt.input);
    let filename = path.display();

    let file = match File::open(&path) {
        Err(err) => panic!("cannot open {}: {}", filename, err.description()),
        Ok(file) => file,
    };


    let mut out: Box<Write> = match opt.output {
        None => Box::new(std::io::stdout()),
        Some(f) => Box::new(File::create(Path::new(&f)).unwrap()),
    };

    let optional = opt.optional;
    let local = opt.local;
    let category = opt.category;

    let reader = BufReader::new(file);
    let packs = reader
        .lines()
        .filter_map(|line| if let Some((name, options)) =
            parser::parse(line.unwrap().as_bytes())
        {
            Some(Package::new(
                name,
                options,
                optional,
                local,
                category.clone(),
            ))
        } else {
            None
        })
        .collect::<Vec<Package>>();

    let result = serde_yaml::to_string(&packs).unwrap();
    let re = Regex::new(r"\n\s+(for|on|build): ~").unwrap();
    let result = re.replace_all(&result, "");

    out.write_all(b"# vim: ft=yaml\n#\n# Generated by pack.\n\n").unwrap();
    out.write_all(result.as_bytes()).unwrap();
}
